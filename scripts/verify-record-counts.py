#!/usr/bin/env python2.7
#
# Compares the counts generated by the output of ProcessWarc and the 
# existing list of record counts for each dataset.
# 

import sys
import os
import glob
import fileinput
import argparse

pjoin = os.path.join

def load_warc_counts(path):
    fp = open(path)
    for line in fp:
        cols = line.split()
        if len(cols) != 2:
            print >> sys.stderr, 'Ignoring line "%s"' % line
    
        fname = cols[0].replace('.warc.gz', '')
        records = int(cols[1])
        yield fname, records
    fp.close()

def load_log_counts(base_dir, log_dir):
    out_files = glob.glob(pjoin(log_dir, '*.out'))
    for line in fileinput.input(out_files):
        cols = line.split()
        if len(cols) != 2:
            print >> sys.stderr, 'Ignoring line "%s"' % line

        fname = os.path.relpath(cols[0], base_dir)
        fname = fname.replace('.tar.gz', '')

        records = int(cols[1])
        yield fname, records


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('record_counts', help='Record counts for the WARC files')
    parser.add_argument('base_dir', help='Base path of the job output directory')
    parser.add_argument('job_log_dir', help='Log directory of the Condor job')

    args = parser.parse_args()

    warc_counts = load_warc_counts(args.record_counts)

    log_counts = dict(load_log_counts(args.base_dir, args.job_log_dir))

    n_errors = 0
    n_ok = 0
    for fname, ref_count in warc_counts:
        if not fname in log_counts:
            print '%s tar.gz missing' % fname
            n_errors += 1
            continue

        tar_count = log_counts[fname]
        if ref_count != tar_count:
            print '%s missmatch warc: %d tar: %d' % (fname, ref_count, tar_count)
            n_errors += 1
        else:
            n_ok += 1

    print >> sys.stderr, 'Errors: %10d' % n_errors
    print >> sys.stderr, 'OK:     %10d' % n_ok
    status = n_errors > 0 and 1 or 0
    sys.exit(status)

if __name__ == '__main__':
    main()
